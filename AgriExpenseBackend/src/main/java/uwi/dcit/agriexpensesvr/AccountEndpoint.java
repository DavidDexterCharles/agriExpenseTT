package uwi.dcit.agriexpensesvr;

import com.google.api.server.spi.config.AnnotationBoolean;
import com.google.api.server.spi.config.Api;
import com.google.api.server.spi.config.ApiMethod;
import com.google.api.server.spi.config.ApiMethod.HttpMethod;
import com.google.api.server.spi.config.ApiNamespace;
import com.google.api.server.spi.response.CollectionResponse;
import com.google.appengine.api.NamespaceManager;
import com.google.appengine.api.datastore.Cursor;
import com.google.appengine.api.datastore.Key;
import com.google.appengine.api.datastore.KeyFactory;
import com.google.appengine.datanucleus.query.JPACursorHelper;

import java.util.List;

import javax.annotation.Nullable;
import javax.inject.Named;
import javax.persistence.EntityExistsException;
import javax.persistence.EntityManager;
import javax.persistence.Query;

@Api(name = "accountApi",
        version = "v1",
        namespace = @ApiNamespace(
                ownerDomain = "agriexpensesvr.dcit.uwi",
                ownerName = "agriexpensesvr.dcit.uwi",
                packagePath = ""
        ))
public class AccountEndpoint {

    /**
     *This inserts a new entity into App Engine datastore. If the entity
     * already exists it simply returns the existing entity. It uses HTTP POST method.
     *
     * @param namespace The name space generated by the user email address attained from the client
     * @param country The country to which the account is associated with
     * @param county The location/subzone within the country that the user is located/registered in
     * @return Returns created or existing account , will return null if operation fails
     */
    @ApiMethod(name="getOrInsertAccount")
    public Account create(@Named("namespace")String namespace, @Named("country") String country, @Named("county")String county){

        NamespaceManager.set(namespace);
        EntityManager mgr = getEntityManager();

        Key k = KeyFactory.createKey("Account", namespace); //TCreate the key for the account based on the namespace supplied
        Account account = new Account(k, KeyFactory.keyToString(k), -1, namespace);
        account.setCountry(country);
        account.setCounty(county);

        if (!containsAccount(account, mgr)){ // Account does not previously exist
            try{
                mgr.persist(account);
                System.out.println("Account Created Successfully");
            }catch(Exception e){
                e.printStackTrace();
                account = null; // Return null to indicate failed attempt at creating an account
            }
            finally {
                mgr.close();
            }
        }else{

            account = retrieve(namespace); // Retrieve th
        }
        return account;
    }

    @ApiMethod(name="getAccount", httpMethod = HttpMethod.GET)
    public Account retrieve(@Named("namespace") String namespace){
        NamespaceManager.set(namespace);
        EntityManager mgr = getEntityManager();

        Account account = mgr.find(Account.class, KeyFactory.createKey("Account", namespace));
        if (account == null)System.out.println("Unable to Find account associated with namespace:"+namespace);
        else System.out.println("Found: " + account);
        mgr.close();
        return account;
    }

    @ApiMethod(name="updateAccount", httpMethod = HttpMethod.PUT)
    public Account update(Account account){
        NamespaceManager.set(account.getAccount());
        EntityManager mgr = getEntityManager();
        if (!containsAccount(account, mgr))
            throw new EntityExistsException("Account with namespace: " + account.getAccount() +" does not exist");
        else{
            mgr.persist(account);
        }
        mgr.close();
        return account;
    }

    public CollectionResponse <Account> listAccounts(@Nullable @Named("cursor") String cursorString, @Nullable @Named("limit") Integer limit) {
        EntityManager mgr = getEntityManager();

        return null;
    }


//    @ApiMethod(name = "insertAccount", httpMethod = HttpMethod.POST)
//    public Account insertAccount(Account account) {
//        NamespaceManager.set(account.getAccount());
//
//        EntityManager mgr = getEntityManager();
//
//        Key k = KeyFactory.createKey("Account", 1);
//        account.setKey(k);
//        account.setKeyrep(KeyFactory.keyToString(k));
//
//        try {
//            if (containsAccount(account)) {
//                throw new EntityExistsException("Object already exists");
//            }
//            mgr.persist(account);
//        } finally {
//            mgr.close();
//        }
//        return account;
//    }

//    /**
//     * This method lists all the entities inserted in datastore. It uses HTTP
//     * GET method and paging support.
//     *
//     * @return A CollectionResponse class containing the list of all entities
//     *         persisted and a cursor to the next page.
//     */
//    @SuppressWarnings({ "unused" })
//    @ApiMethod(name = "listAccounts", httpMethod = HttpMethod.GET, path="all")
//    public CollectionResponse <Account> listAccounts(@Nullable @Named("cursor") String cursorString, @Nullable @Named("limit") Integer limit) {
//
//        EntityManager mgr = null;
//        Cursor cursor;
//        List<Account> execute;
//
//        try {
//            mgr = getEntityManager();
//            Query query = mgr.createQuery("select from UpAcc as UpAcc");
//            if (cursorString != null && !cursorString.equalsIgnoreCase("")) {
//                cursor = Cursor.fromWebSafeString(cursorString);
//                query.setHint(JPACursorHelper.CURSOR_HINT, cursor);
//            }
//
//            if (limit != null) {
//                query.setFirstResult(0);
//                query.setMaxResults(limit);
//            }
//
//            execute = query.getResultList();
//            cursor = JPACursorHelper.getCursor(execute);
//            if (cursor != null)
//                cursorString = cursor.toWebSafeString();
//
//            // Tight loop for fetching all entities from datastore and
//            // accomodate
//            // for lazy fetch.
////            for (Account obj : execute)
////                ;
//        } finally {
//            if (mgr != null)mgr.close();
//        }
//
//        return CollectionResponse.<Account> builder().setItems(execute)
//                .setNextPageToken(cursorString).build();
//    }
//
//    /**
//     * This method gets the entity having primary key id. It uses HTTP GET
//     * method.
//     *
//     * @param id
//     *            the primary key of the java bean.
//     * @return The entity with primary key id.
//     */
//    @ApiMethod(name = "getAccount", httpMethod = HttpMethod.GET, path = "")
//    public Account getAccount(@Named("id") Long id, @Named("namespace") String namespace) {
//        NamespaceManager.set(namespace);
//        EntityManager mgr = getEntityManager();
//        Account account = null;
//        try {
//            account = mgr.find(Account.class, id);
//            System.out.println("CLOUD-ACCOUNT:" + account.toString());
//        } catch (Exception e) {
//            e.printStackTrace();
//        } finally {
//            mgr.close();
//        }
//        return account;
//    }
//

//
//    /**
//     * This method is used for updating an existing entity. If the entity does
//     * not exist in the datastore, an exception is thrown. It uses HTTP PUT
//     * method.
//     *
//     * @param upacc
//     *            the entity to be updated.
//     * @return The updated entity.
//     */
//    @ApiMethod(name = "updateUpAcc", httpMethod = HttpMethod.PUT)
//    public Account updateUpAcc(Account upacc) {
//        NamespaceManager.set(upacc.getAccount());
//        EntityManager mgr = getEntityManager();
//        Key k = KeyFactory.stringToKey(upacc.getKeyrep());
//        Account acc = mgr.find(Account.class, k);
//        if (acc.getLastUpdated() < upacc.getLastUpdated()) {
//            acc.setLastUpdated(upacc.getLastUpdated());
//            mgr.persist(acc);
//        }
//        mgr.close();
//
//        return upacc;
//    }
//
//    /**
//     * This method removes the entity with primary key id. It uses HTTP DELETE
//     * method.
//     *
//     * @param id
//     *            the primary key of the entity to be deleted.
//     */
//    @ApiMethod(name = "removeAccount")
//    public void removeAccount(@Named("id") Long id) {
//        EntityManager mgr = getEntityManager();
//        try {
//            Account upacc = mgr.find(Account.class, id);
//            mgr.remove(upacc);
//        } finally {
//            mgr.close();
//        }
//    }

    private boolean containsAccount(Account account, EntityManager mgr) {
        boolean contains = true;
        try {
            Account item = mgr.find(Account.class, account.getKey());
            if (item == null) {
                contains = false;
            } else {
                System.out.println("Retrieved: " + item.toString());
            }
        }catch (Exception e){e.printStackTrace();}
        return contains;
    }
    private static EntityManager getEntityManager() {
        return EMF.get().createEntityManager();
    }

}